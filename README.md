# opensw
리눅스 명어 top, ps, jobs, kill 명령어에 대한 조사

## top
top 명령어의 주요 기능
1. 실시간 시스템 모니터링
cpu, 메모리, 스왑 사용량, 시스템 업타임 등 시스템의 상태를 실시간으로 표시
2. 프로세스 정보
현재 실행하고 있는 모든 프로세스 목록을 표시, 각 프로세스의 PID, 사용자, CPU, 메모리 사용률, 실행 시간, 명령어 등을 보여줌
3. 정렬 및 필터링
기본적으로 CPU 사용률을 기준으로 프로세스 정렬, but 메모리 사용량, PID 등 다양한 기준으로 정렬 가능
특정 사용자의 프로세스만을 볼 수 있고 특정 조건에 맞는 프로세스를 필터링 가능

top 명령어
<img width="851" alt="image" src="https://github.com/ssswoowoook/opensw/assets/170293211/bde5bd69-6104-4bf8-9652-3dce83df8abc">

top 명령어의 주요 인터페이스 요소
시스템 시간, 업타임, 사용자 세션 수, 로드 평균, 작업 상태, CPU 상태, 메모리 사용량, 스왑 사용량

프로세스 목록
PID, 사용자 이름, 우선 순위, NICE 값, 가상 메모리 사용량(VIRT), 물리 메모리 사용량(RES), 공유 메모리 사용량(SHR), CPU 사용률(%CPU), 메모리 사용률(%MEM), 실행 시간(TIME+), 명령어(CMD) 등이 표시

- 'top': 명령어의 상호작용 키
- 'h': 도움말 표시
- 'q': top 명령어를 종료
- 'k': 프로세스 종료, PID 입력
- 'r': 프로세스 우선순위 변경
- 'u': 특정 사용자의 프로세스만 표시
- 'p': CPU 사용률을 기준으로 정렬
- 'M': 메모리 사용률을 기준으로 정렬
- 'N': PID를 기준으로 정렬
- 'T': 실행시간을 기준으로 정렬
- 'c': 전체 명령어 라인을 표시하거나 숨김
- '1': 각 CPU 코어별 사용량을 표시

- '-b': 배치 모드롤 실행
- '-n': 출력할 갱신 횟수를 지정
- '-u': 특정 사용자의 프로세만 표시

<img width="854" alt="image" src="https://github.com/ssswoowoook/opensw/assets/170293211/0afc969c-bfa8-477e-b33a-752412502fbd">



top 명령어는 리눅스 시스템 관리자가 시스템 성능을 모니터링하고 문제를 해결하는 데 필수적인 도구이다. 시스템 자원을 효율적으로 관리하고, 문제 발생 시 빠르게 대응 가능

## ps
리눅스에서 ps 명령어는 현재 실행 중인 프로세스 목록과 해당 프로세스의 상태를 표시하는데 사용, ps 명령어는 정적인 정보를 제공하며, 다양한 옵션을 통해 상세한 프로세스 정보를 확인 가능

<img width="854" alt="image" src="https://github.com/ssswoowoook/opensw/assets/170293211/756b56b2-4662-4395-8d0c-1ecb480d0b2a">
- PID: 프로세스 ID
- TTY: 터미널 타입
- TIME: CPU 사용 시간
- CMD: 실행된 명령어

주요 옵션: ps 명령어는 다양한 옵션을 지원, 원하는 정보를 더욱 상세하게 또는 특정 조건에 맞게 필터링하여 시각화 가능

일반적인 옵션
- '-A' or '-e': 시스템의 모든 프로세스 표시
- '-a': 다른 사용자의 프로세스도 포함하여 현재 터미널에서 실행 중인 모든 프로세스 표시
- '-u': 특정 사용자의 프로세스 표시
- '-x': 터미널에 종속되지 않은 프로세스를 포함하여 표시

포멧 지정 옵션
-'-f': 전체 포맷으로 자세한 정보 표시
- '-l': 긴 포맷으로 자세한 정보 표시
- '-o': 출력 형식을 사용자 지정으로 설정

사용자와 그리드 옵션
- '-U [user]': 특정 사용자의 프로세스 표시
- '-G [group]': 특정 그룹의 프로세스 표시

PID와 부모 프로세스 ID 옵션
- '-p [pid]': 특정 PID의 프로세스 표시
- '--ppid [ppid]': 특정 부모 프로세스 ID를 가진 프로세스를 표시

BSD 스타일 옵션
- 'aux': 다양한 정보를 포괄적으로 표시, 보통 BSD 계열 시스템에서 사용되지만 리눅스에서도 유사하게 사용 가능

- ps 명령어의 출력 형식 설명
- PID: 프로세스 ID
- TTY: 프로세스가 연결된 터미널
- TIME: 프로세스가 사용한 총 CPU 시간
- CMD: 실행된 명령어
- USER: 프로세스를 실행한 사용자
- %CPU: CPU 사용률
- %MEM: 메모리 사용률
- VSZ: 가상 메모리 크기
- RSS: 실제 메모리 사용량
- START: 프로세스 시작 시간
- STAT: 프로세스 상태

장점: ps 명령어를 사용하면 현재 실행 중인 모든 프로세스의 정보를 한 눈에 확인 가능, 다양한 옵션을 사용하여 원하는 조건에 따른 프로세스만 필터링 가능
단점: ps 명령어는 현재 상태의 스냅샷을 보여주기 때문에 실시간으로 변하는 프로세스 상태를 확인하기에는 부적합, 모든 프로세스를 보여준다는 점에서 출력 결과가 많을 수 있기 때문에 원하는 정보를 찾기에 다소 어려

ps 명령어는 리눅스 시스템의 프로세스 정보를 확인하고 관리하는데 필수적인 도구, 다양한 옵션을 통해 특정 조건에 맞는 프로세스를 필터링하고, 필요한 정보를 효율적으로 추출 가능

## jobs
리눅스에서 jobs 명령어는 현재 셀 세션에서 백그라운드 또는 중지된 작업(프로세스)을 표시하는데 사용, 주로 작업 제어 기능과 관련 있으며, 사용자가 실행 중인 프로세스를 관리하는데 유용

jobs 명령어는 현재 쉘 세션에서 실행 중이거나 중지된 모든 작업을 표시
<img width="859" alt="image" src="https://github.com/ssswoowoook/opensw/assets/170293211/44264081-955c-44d2-968e-a3cc6cf1ebad">
- 작업 번호: 각 작업에 할당된 번호
- 작업 상태: 실행 중, 중지됨, 완료됨 등
- 명령어: 실행된 명령어 라인

주요 옵션
- '-l': 각 작업에 대한 PID를 포함하여 자세한 정보 표시
- '-n': 상태가 변경된 작업만을 표시
- '-p': 각 작업의 프로세스 ID만 표시
- '-r': 실행 중인 작업만을 표시
- '-s': 중지된 작업만 표시

백그라운 작업 제어
jobs 명령어는 백그라운드 및 중지된 작업을 관리하는 데 자주 사용

장점: 현재 쉘 세션에서 실행 중인 작업 목록을 간단하게 확인 가능
단점: 백그라운드에서 실행 중인 다른 쉘 세션의 작업 목록을 확인 불가, 자세한 정보 제공 하지 않음

jobs 명령어는 쉘 세션에서 실행 중인 작업을 관리하고 모니터링하는 데 유용한 도구, 이를 통해 사용자는 백그라운드 및 중지된 작업을 쉽게 확인하고, 필요에 따라 작업을 포그라운드로 가져오거나 백그라운드로 전송 가능 -> 효율적인 작업 관리를 가능하게 하며, 시스템 리소스를 효과적으로 활용

## kill
kill 명령어는 프로세스에게 신호를 보내는 명령어로, 주로 프로세스를 종료하거나 특정 동작을 유발하는데 사용, 단순하게 프로세스를 강제 종료하는 데만 쓰이는 것이 아니라, 다양한 신호를 통해 프로세스에 여러 가지 명령 가능

주요 옵션
- '-s <signal>': 특정 시그널을 사용하여 프로세스 종료
- '-l', '--list': 지원되는 시그널 목록을 출력
- '-a', '--all': 현재 사용자에 속한 모든 프로세스 종료
- '-q', '--queue': 프로세스에 시그널을 보내는 대신 시그널을 대기열에 추가

주요 신호들
- TERM (15): 정상 종료 신호. 프로세스가 종료될 때 정리 작업 가능
- KILL (9): 강제 종료 신호. 프로세스를 즉시 종료시키며 정리 작업 불가
- HUP (1): 프로세스 재시작 신호. 주로 데몬 프로세스를 재시작하는 데 사용
- INT (2): 인터럽트 신호. Ctrl+C로 보낼 수 있는 신호와 동일
- QUIT (3): 종료 신호. 프로세스가 코어 덤프를 생성하고 종료
- STOP (19): 프로세스 정지 신호. 프로세스를 일시 정지
- CONT (18): 정지된 프로세스를 다시 실행

장점: 간단한 명령어로 빠르게 프로세스를 종료, 다양한 옵션을 사용하여 프로세스 동작을 제어 가능
단점: 잘못 사용되면 의도치 않은 프로세스 종료가 발생, 시그널을 사용하여 강제 종료할 경우, 프로세스가 올바르게 정리되지 않을 수 있고, 데이터 손실 등의 문제 발생 가능성

리눅스에서 kill 명령어를 사용하여 프로세스를 종료 가능. 이를 통해 원하는 프로세스를 간편하게 제어하고 운영체제의 안정성을 유지 가능 but, kill 명령어 사용 시 주의가 필
